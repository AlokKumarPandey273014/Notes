
Question: What is Polymorphism and how many types of polymorphism?

Polymorphism: It is one of the important pillars of Object-Oriented Programming (OOP).
              The word Polymorphism comes from two Greek words:
              โข Poly = many
              โข Morphi = form
              Meaning: "One object behaving in many different forms."

Example:
A man can play multiple roles in life โ as a son, as a husband, and as a father.
Similarly, in OOP, polymorphism allows one object to exhibit different behaviors.

Types of Polymorphism in C#:
There are two types of polymorphism in C#:
1. Static Polymorphism (Compile Time Polymorphism)
2. Dynamic Polymorphism (Run Time Polymorphism)

Static Polymorphism (Compile Time Polymorphism):
i) Achieved at compile time.
ii) When a function is linked with an object at compile time, it is called static polymorphism or early binding.
iii) In C#, static polymorphism is achieved in two ways:
     a) Method Overloading (Function Overloading)
     b) Operator Overloading

Dynamic Polymorphism (Run Time Polymorphism):
i) Achieved at run time.
ii) When a function is linked with an object at run time, it is called dynamic polymorphism or late binding.
iii) In C#, dynamic polymorphism is achieved using Method Overriding.


โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ




Question: What is Method Overloading?

Method Overloading: When multiple methods in the same class have the same name but differ in the number of parameters, 
                    the type of parameters, or the order of parameters, it is called Method Overloading.
                    It is an example of Compile-time Polymorphism because the decision of which method to call 
                    is made at compile time.

Important Note:
Method Overloading depends only on parameters.
Changing only the return type does not constitute overloading.

Exp:-

class Example
{
    void Display()
    {
        Console.WriteLine("No parameters");
    }

    void Display(int a)
    {
        Console.WriteLine("Integer parameter: " + a);
    }

    void Display(double a)
    {
        Console.WriteLine("Double parameter: " + a);
    }

    void Display(int a, float b)
    {
        Console.WriteLine("Integer and Float parameters: " + a + ", " + b);
    }

    void Display(float a, int b)
    {
        Console.WriteLine("Float and Integer parameters: " + a + ", " + b);
    }

    static void Main()
    {
        Example obj = new Example();

        obj.Display();
        obj.Display(10);
        obj.Display(12.5);
        obj.Display(5, 3.2f);
        obj.Display(2.5f, 7);
    }
}

Output:
No parameters
Integer parameter: 10
Double parameter: 12.5
Integer and Float parameters: 5, 3.2
Float and Integer parameters: 2.5, 7

Ways to Achieve Method Overloading:
1. By changing the number of parameters
2. By changing the data type of parameters
3. By changing the order of parameters

----------------------------------------------------------------------------------

i) By Changing Number of Parameters:

using System;

namespace MethodOverload
{
    class Program
    {
        void Display(int a)
        {
            Console.WriteLine("Argument: " + a);
        }

        void Display(int a, int b)
        {
            Console.WriteLine("Arguments: " + a + ", " + b);
        }

        static void Main(string[] args)
        {
            Program obj = new Program();
            obj.Display(100);          // 1 parameter
            obj.Display(100, 200);     // 2 parameters
        }
    }
}

Output:
Argument: 100
Arguments: 100, 200

Explanation:
One method has one parameter, another has two parameters.
Because the number of parameters is different, method overloading is achieved.


----------------------------------------------------------------------------------

ii) By Changing Data Type of Parameters:

using System;

namespace MethodOverload
{
    class Program
    {
        void Display(int a)
        {
            Console.WriteLine("int type: " + a);
        }

        void Display(string a)
        {
            Console.WriteLine("string type: " + a);
        }

        static void Main(string[] args)
        {
            Program obj = new Program();
            obj.Display(100);        // int
            obj.Display("Alok");     // string
        }
    }
}

Output:
int type: 100
string type: Alok

Explanation:
One method accepts an int parameter, another accepts a string parameter.
Because the data types are different, method overloading is valid.


----------------------------------------------------------------------------------

iii) By Changing Order of Parameters:

using System;

namespace MethodOverload
{
    class Program
    {
        void Display(int a, string b)
        {
            Console.WriteLine("int: " + a);
            Console.WriteLine("string: " + b);
        }

        void Display(string a, int b)
        {
            Console.WriteLine("string: " + a);
            Console.WriteLine("int: " + b);
        }

        static void Main(string[] args)
        {
            Program obj = new Program();
            obj.Display(100, "Programming");   // int, string
            obj.Display("Alok", 30);           // string, int
        }
    }
}

Output:
int: 100
string: Programming
string: Alok
int: 30

Explanation:
Both methods use the same parameter types (int and string), 
but the order of parameters is different. Therefore, overloading is valid.


----------------------------------------------------------------------------------

Final Summary:

โ Method Overloading means having multiple methods with the same name in a class.  
โ The difference must be in the number of parameters, the type of parameters, or the order of parameters.  
โ Return type alone does not constitute method overloading.  
โ It is resolved at compile-time, so it is also called Static Polymorphism.











๐ถ Question: What is Operator Overloading?

๐งพ Answer:

โ Operator Overloading (เคเคชเคฐเฅเคเคฐ เคเคตเคฐเคฒเฅเคกเคฟเคเค)

โข Operator Overloading compile-time polymorphism เคเคพ example เคนเฅเฅค  
โข เคเคธเคเคพ เคฎเคคเคฒเคฌ เคนเฅ เคเคฟ เคนเคฎ C# เคฎเฅเค operators เคเฅเคธเฅ `+`, `-`, `*`, `/` เคเฅ redefine เคเคฐ เคธเคเคคเฅ เคนเฅเค เคคเคพเคเคฟ เคตเฅ user-defined data types (class/struct) เคชเคฐ เคเคพเคฎ เคเคฐเฅเคเฅค  
โข เคเคธเคธเฅ เคนเคฎ เคเคชเคจเฅ objects เคชเคฐ เคเคธเฅ เคคเคฐเคน operations เคเคฐ เคธเคเคคเฅ เคนเฅเค เคเฅเคธเฅ primitive types (int, string, etc.) เคชเคฐ เคเคฐเคคเฅ เคนเฅเคเฅค

๐ เคเคธเคเคพ syntax เคนเฅเคคเคพ เคนเฅ:
    public static <ClassName> operator <symbol>(<ClassName> obj1, <ClassName> obj2)

----------------------------------------------------------------------------------

โ Example Code:

using System;

namespace OperatorOverloading
{
    class Abc
    {
        public string Str;
        public int Num;

        // '+' Operator Overloading
        public static Abc operator +(Abc obj1, Abc obj2)
        {
            Abc obj3 = new Abc();
            obj3.Str = obj1.Str + " " + obj2.Str;
            obj3.Num = obj1.Num + obj2.Num;
            return obj3;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Abc obj1 = new Abc { Str = "Alok", Num = 10 };
            Abc obj2 = new Abc { Str = "Kumar", Num = 20 };

            Abc obj3 = obj1 + obj2;  // '+' operator เคเคพ overloaded version call เคนเฅเคเคพ

            Console.WriteLine(obj3.Str);
            Console.WriteLine(obj3.Num);
        }
    }
}

๐จ๏ธ Output:
Alok Kumar  
30

๐งพ Explanation:
เคฏเคนเคพเค เคฆเฅ objects เคเฅ '+' operator เคธเฅ เคเฅเคกเคผเคพ เคเคฏเคพ เคนเฅเฅค '+' operator internally เคเค static method call เคเคฐ เคฐเคนเคพ เคนเฅ เคเคฟเคธเฅ เคนเคฎเคจเฅ overload เคเคฟเคฏเคพ เคนเฅเฅค

----------------------------------------------------------------------------------

๐ Notes (เคฎเคนเคคเฅเคตเคชเฅเคฐเฅเคฃ เคฌเคพเคคเฅเค):

โข Operator overloading compile-time polymorphism เคเคพ เคนเคฟเคธเฅเคธเคพ เคนเฅเฅค  
โข เคนเคฎ เคเค เคนเฅ operator เคเฅ เคเคฒเค-เคเคฒเค เคเคพเคฎเฅเค เคเฅ เคฒเคฟเค use เคเคฐ เคธเคเคคเฅ เคนเฅเคเฅค  
โข เคนเคฎ เคธเคฟเคฐเฅเคซ predefined operators เคเฅ เคนเฅ overload เคเคฐ เคธเคเคคเฅ เคนเฅเคเฅค  
โข Overloaded operator เคเค static method เคนเฅเคคเคพ เคนเฅ เคเคฐ `operator` keyword เคธเฅ define เคนเฅเคคเคพ เคนเฅเฅค

----------------------------------------------------------------------------------

๐ธ Table: เคเฅเคจ-เคเฅเคจ เคธเฅ Operators Overload เคเคฟเค เคเคพ เคธเคเคคเฅ เคนเฅเค?

| Operator                | Description                                           | Overloadable? |
|------------------------|-------------------------------------------------------|---------------|
| +, -, *, /, %          | Arithmetic Operators (binary)                         | โ Yes        |
| ++, --, !, ~           | Unary Operators                                       | โ Yes        |
| ==, !=, <, >, <=, >=   | Comparison Operators                                   | โ Yes        |
| &&, ||                 | Conditional Logical Operators                         | โ No         |
| =, +=, -=, *=, /=, %=  | Assignment Operators                                  | โ No         |

----------------------------------------------------------------------------------

๐ฏ Summary (เคจเคฟเคเฅเคกเคผ):

โ Operator overloading เคธเฅ เคนเคฎ operator เคเฅ user-defined object types เคเฅ เคฒเคฟเค customize เคเคฐ เคธเคเคคเฅ เคนเฅเคเฅค  
โ เคเคธเคเคพ เคเคชเคฏเฅเค เคเคฐเคเฅ เคเคช readable เคเคฐ meaningful code เคฒเคฟเค เคธเคเคคเฅ เคนเฅเคเฅค  
โ Operator overloading static method เคเฅ เคฐเฅเคช เคฎเฅเค implement เคนเฅเคคเฅ เคนเฅเฅค  
โ เคเฅเค operators เคเฅเคธเฅ `=`, `+=`, `||` เคเคฆเคฟ เคเฅ overload เคจเคนเฅเค เคเคฟเคฏเคพ เคเคพ เคธเคเคคเคพเฅค

๐ เคเคเคฐ เคเคช เคเคพเคนเฅเค เคคเฅ เคฎเฅเค Comparison เคญเฅ เคฌเคจเคพ เคธเคเคคเคพ เคนเฅเค โ Operator Overloading vs Method Overloadingเฅค













โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ




๐ท Question: What is Dynamic or Run-Time Polymorphism?

๐งพ Answer:

โข เคเคฌ เคเคฟเคธเฅ program เคฎเฅเค เคเคฟเคธเฅ method เคเฅ run-time เคชเคฐ select เคเคฟเคฏเคพ เคเคพเคคเคพ เคนเฅ, เคเคธเฅ **Run-Time Polymorphism** เคฏเคพ **Dynamic Polymorphism** เคเคนเคคเฅ เคนเฅเคเฅค  
โข เคเคธเฅ achieve เคเคฟเคฏเคพ เคเคพเคคเคพ เคนเฅ **Method Overriding** เคเฅ เคเคผเคฐเคฟเคเฅค

๐ง Key Point:
- Base class เคฎเฅเค method เคเฅ `virtual` declare เคเคฟเคฏเคพ เคเคพเคคเคพ เคนเฅ  
- Derived class เคฎเฅเค เคเคธเฅ method เคเฅ `override` เคเคฟเคฏเคพ เคเคพเคคเคพ เคนเฅ

----------------------------------------------------------------------------------

๐ท Question: What is Method Overriding?

๐งพ Answer:

โข เคเคฌ derived class เคฎเฅเค base class เคเฅ เคเคฟเคธเฅ method เคเฅ **same name เคเคฐ same parameter** เคเฅ เคธเคพเคฅ redefine เคเคฟเคฏเคพ เคเคพเคคเคพ เคนเฅ, เคคเฅ เคเคธเฅ Method Overriding เคเคนเคคเฅ เคนเฅเคเฅค  
โข เคฏเคน runtime polymorphism เคเฅ achieve เคเคฐเคคเคพ เคนเฅเฅค

โ Method Overriding เคเฅ Rules:
- Base class method โ `virtual` keyword เคธเฅ mark เคนเฅเคจเคพ เคเคพเคนเคฟเค  
- Derived class method โ `override` keyword เคธเฅ implement เคนเฅเคจเคพ เคเคพเคนเคฟเค  
- Signature (method name + parameter list) เคฆเฅเคจเฅเค เคเคเคน same เคนเฅเคจเคพ เคเคพเคนเคฟเค

----------------------------------------------------------------------------------

โ Example 1:

using System;

namespace Overriding
{
    class Parent
    {
        public virtual void Print()
        {
            Console.WriteLine("This is a parent class");
        }
    }

    class Child : Parent
    {
        public override void Print()
        {
            Console.WriteLine("This is a child class");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Parent p = new Child();
            p.Print();
        }
    }
}

๐จ๏ธ Output:
This is a child class

โก๏ธ เคฏเคนเคพเค Parent class เคฎเฅเค `Print()` method virtual เคนเฅ  
โก๏ธ Child class เคเคธเฅ override เคเคฐ เคฐเคนเฅ เคนเฅ  
โก๏ธ เคเคฌ เคนเคฎ `Parent p = new Child()` เคเคฐเคเฅ `p.Print()` call เคเคฐเคคเฅ เคนเฅเค โ เคคเคฌ output เคเคคเคพ เคนเฅ **"This is a child class"**

----------------------------------------------------------------------------------

โ Example 2:

using System;

namespace MethodOverriding
{
    class Animal
    {
        public virtual void Eat()
        {
            Console.WriteLine("Eating...");
        }
    }

    class Dog : Animal
    {
        public override void Eat()
        {
            Console.WriteLine("Eating Bread");
        }
    }

    class Program
    {
        static void Main()
        {
            Dog d = new Dog();
            d.Eat();
        }
    }
}

๐จ๏ธ Output:
Eating Bread

โก๏ธ เคฏเคนเคพเค Animal class เคฎเฅเค `Eat()` method เคเฅ virtual เคเคฟเคฏเคพ เคเคฏเคพ เคนเฅ  
โก๏ธ Dog class เคจเฅ เคเคธเฅ override เคเคฐเคเฅ เคเคชเคจเฅ implementation เคฆเฅ เคนเฅ

----------------------------------------------------------------------------------

๐ Summary Table โ Static vs Dynamic Polymorphism:

| Type                 | Binding Time | Implemented Using                        | Example                     |
|----------------------|--------------|------------------------------------------|-----------------------------|
| Static Polymorphism  | Compile-Time | Method Overloading, Operator Overloading | `Display(int)` `+ operator` |
| Dynamic Polymorphism | Run-Time     | Method Overriding                        | `virtual/override`          |




โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ



๐ท What is Method Hiding in C#?

โ Definition (เคนเคฟเคเคฆเฅ + English):
Method Hiding C# เคเคพ เคเค inheritance concept เคนเฅ เคเคฟเคธเคฎเฅเค **derived (child) class** เคเค เคเคธเคพ method define เคเคฐเคคเฅ เคนเฅ เคเฅ base (parent) class เคเฅ method เคธเฅ **same name เคเคฐ signature** เคฐเคเคคเคพ เคนเฅ, เคฒเฅเคเคฟเคจ เคเคธเฅ **override เคจเคนเฅเค เคเคฐเคคเฅ** โ เคฌเคฒเฅเคเคฟ เคเคธเฅ **hide** เคเคฐ เคฆเฅเคคเฅ เคนเฅเฅค

โ เคเคธเฅ `new` keyword เคธเฅ เคเคฟเคฏเคพ เคเคพเคคเคพ เคนเฅเฅค  
โ เคฏเฅ **compile time เคชเคฐ resolve เคนเฅเคคเคพ เคนเฅ**เฅค  
โ เคฏเฅ **polymorphism เคเคพ เคนเคฟเคธเฅเคธเคพ เคจเคนเฅเค เคนเฅ**เฅค  
โ เคฏเฅ **inheritance เคธเฅ related** เคนเฅเฅค

---

๐ Syntax:
```csharp
public new void MethodName() { }
```

---

๐งช Example: Method Hiding

```csharp
using System;

class Parent
{
    public void Show()
    {
        Console.WriteLine("Parent Show Method");
    }
}

class Child : Parent
{
    public new void Show()  // hides the Parent's Show method
    {
        Console.WriteLine("Child Show Method");
    }
}

class Program
{
    static void Main()
    {
        Parent p = new Child();  // Base class reference to derived object
        p.Show();                // Output: Parent Show Method (method hiding)

        Child c = new Child();   // Derived class reference
        c.Show();                // Output: Child Show Method
    }
}
```

---

๐ฏ Output:
```
Parent Show Method
Child Show Method
```


๐ Key Points (เคฎเคนเคคเฅเคตเคชเฅเคฐเฅเคฃ เคฌเคพเคคเฅเค):
- `new` keyword เคฌเคคเคพเคคเคพ เคนเฅ เคเคฟ child class เคเคพ method, base class เคเคพ method **hide เคเคฐ เคฐเคนเคพ เคนเฅ**เฅค
- เคเคเคฐ เคนเคฎ object เคเฅ **parent class type** เคธเฅ call เคเคฐเฅเคเคเฅ โ parent เคเคพ method เคเคฒเฅเคเคพเฅค
- เคเคเคฐ เคนเคฎ object เคเฅ **child class type** เคธเฅ call เคเคฐเฅเคเคเฅ โ child เคเคพ method เคเคฒเฅเคเคพเฅค
- เคฏเฅ **method overriding เคจเคนเฅเค เคนเฅ**, เคเคธเคฒเคฟเค เคฏเฅ **runtime polymorphism** เคเคพ เคนเคฟเคธเฅเคธเคพ เคจเคนเฅเค เคนเฅเฅค

---

๐ Comparison: Method Hiding vs Method Overriding

| Feature               | Method Hiding              | Method Overriding           |
|-----------------------|-----------------------------|------------------------------|
| Keyword used          | `new`                      | `override`                  |
| Base method required  | Any access modifier         | Must be `virtual`, `abstract`, or `override` |
| Resolution time       | Compile-time               | Runtime                      |
| Polymorphism?         | โ No                      | โ Yes                       |
| Purpose               | Hide base method           | Extend/Replace base method   |

---

โ Summary (เคธเคพเคฐเคพเคเคถ):
- Method Hiding เคคเคฌ เคนเฅเคคเคพ เคนเฅ เคเคฌ derived class same เคจเคพเคฎ เคเคพ method define เคเคฐเคคเฅ เคนเฅ, เคเคฐ เคเคธเฅ `new` เคธเฅ hide เคเคฐเคคเฅ เคนเฅเฅค
- เคฏเคน inheritance เคเคพ feature เคนเฅ เคฒเฅเคเคฟเคจ polymorphism เคเคพ เคนเคฟเคธเฅเคธเคพ เคจเคนเฅเคเฅค
- Method hiding compile time เคชเคฐ decide เคนเฅเคคเคพ เคนเฅ เคเคฟ เคเฅเคจ เคธเคพ method call เคนเฅเคเคพ โ reference type เคเฅ base เคชเคฐเฅค

๐ง Interview Tip:
"Method hiding is a compile-time concept in C# that hides a base class method using `new` keyword instead of overriding it."













